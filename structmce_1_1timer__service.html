<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppCoroutineCurrency: mce::timer_service Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CppCoroutineCurrency
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mce</b></li><li class="navelem"><a class="el" href="structmce_1_1timer__service.html">timer_service</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structmce_1_1timer__service-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mce::timer_service Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="timer_8hpp_source.html">timer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a683b0453565ebb21813077292f6c9e1c"><td class="memItemLeft" align="right" valign="top"><a id="a683b0453565ebb21813077292f6c9e1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#a683b0453565ebb21813077292f6c9e1c">timer_service</a> ()</td></tr>
<tr class="memdesc:a683b0453565ebb21813077292f6c9e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a683b0453565ebb21813077292f6c9e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0df685790cca2967cd69fbba54d3dd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#af0df685790cca2967cd69fbba54d3dd0">~timer_service</a> ()</td></tr>
<tr class="separator:af0df685790cca2967cd69fbba54d3dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace28e975a1729a9730ea5011f3b9c0e8"><td class="memItemLeft" align="right" valign="top"><a id="ace28e975a1729a9730ea5011f3b9c0e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#ace28e975a1729a9730ea5011f3b9c0e8">start</a> ()</td></tr>
<tr class="memdesc:ace28e975a1729a9730ea5011f3b9c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">start timer service on current thread <br /></td></tr>
<tr class="separator:ace28e975a1729a9730ea5011f3b9c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbac7512a4f43f8e22cde3b6e95dbccb"><td class="memItemLeft" align="right" valign="top"><a id="afbac7512a4f43f8e22cde3b6e95dbccb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#afbac7512a4f43f8e22cde3b6e95dbccb">ready</a> ()</td></tr>
<tr class="memdesc:afbac7512a4f43f8e22cde3b6e95dbccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">blocks until service is running <br /></td></tr>
<tr class="separator:afbac7512a4f43f8e22cde3b6e95dbccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37f2d6584e8c8bb775a2961c0916909"><td class="memItemLeft" align="right" valign="top"><a id="ae37f2d6584e8c8bb775a2961c0916909"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#ae37f2d6584e8c8bb775a2961c0916909">shutdown</a> ()</td></tr>
<tr class="memdesc:ae37f2d6584e8c8bb775a2961c0916909"><td class="mdescLeft">&#160;</td><td class="mdescRight">inform service to shutdown and join with service <br /></td></tr>
<tr class="separator:ae37f2d6584e8c8bb775a2961c0916909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f41ed7d27dcea436dc7cb67325d6539"><td class="memTemplParams" colspan="2">template&lt;typename THUNK &gt; </td></tr>
<tr class="memitem:a9f41ed7d27dcea436dc7cb67325d6539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#a9f41ed7d27dcea436dc7cb67325d6539">timer</a> (const mce::time_point &amp;timeout, THUNK &amp;&amp;timeout_handler)</td></tr>
<tr class="memdesc:a9f41ed7d27dcea436dc7cb67325d6539"><td class="mdescLeft">&#160;</td><td class="mdescRight">start timer  <a href="structmce_1_1timer__service.html#a9f41ed7d27dcea436dc7cb67325d6539">More...</a><br /></td></tr>
<tr class="separator:a9f41ed7d27dcea436dc7cb67325d6539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7194412c78c80a697b62f695c2abd3"><td class="memTemplParams" colspan="2">template&lt;typename THUNK &gt; </td></tr>
<tr class="memitem:aad7194412c78c80a697b62f695c2abd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#aad7194412c78c80a697b62f695c2abd3">timer</a> (const mce::duration &amp;d, THUNK &amp;&amp;timeout_handler)</td></tr>
<tr class="memdesc:aad7194412c78c80a697b62f695c2abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">start timer  <a href="structmce_1_1timer__service.html#aad7194412c78c80a697b62f695c2abd3">More...</a><br /></td></tr>
<tr class="separator:aad7194412c78c80a697b62f695c2abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4549f972efbe5078434c179038e2cf95"><td class="memTemplParams" colspan="2">template&lt;typename THUNK &gt; </td></tr>
<tr class="memitem:a4549f972efbe5078434c179038e2cf95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#a4549f972efbe5078434c179038e2cf95">timer</a> (const time_unit u, size_t <a class="el" href="structmce_1_1timer__service.html#a420bfe8f24dd900f595369ef59b892c1">count</a>, THUNK &amp;&amp;timeout_handler)</td></tr>
<tr class="memdesc:a4549f972efbe5078434c179038e2cf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">start timer  <a href="structmce_1_1timer__service.html#a4549f972efbe5078434c179038e2cf95">More...</a><br /></td></tr>
<tr class="separator:a4549f972efbe5078434c179038e2cf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99622e95a85c2f9c1f636bb80b7b5338"><td class="memItemLeft" align="right" valign="top"><a id="a99622e95a85c2f9c1f636bb80b7b5338"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#a99622e95a85c2f9c1f636bb80b7b5338">running</a> (<a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a> id)</td></tr>
<tr class="memdesc:a99622e95a85c2f9c1f636bb80b7b5338"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if timer is running, else false <br /></td></tr>
<tr class="separator:a99622e95a85c2f9c1f636bb80b7b5338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49692dfba6f88fa6248b60222fc316a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#ad49692dfba6f88fa6248b60222fc316a">remove</a> (<a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a> id)</td></tr>
<tr class="memdesc:ad49692dfba6f88fa6248b60222fc316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a running timer  <a href="structmce_1_1timer__service.html#ad49692dfba6f88fa6248b60222fc316a">More...</a><br /></td></tr>
<tr class="separator:ad49692dfba6f88fa6248b60222fc316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2577939853b10b0bd24c0da11b44182b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#a2577939853b10b0bd24c0da11b44182b">clear</a> ()</td></tr>
<tr class="memdesc:a2577939853b10b0bd24c0da11b44182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all pending timers  <a href="structmce_1_1timer__service.html#a2577939853b10b0bd24c0da11b44182b">More...</a><br /></td></tr>
<tr class="separator:a2577939853b10b0bd24c0da11b44182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420bfe8f24dd900f595369ef59b892c1"><td class="memItemLeft" align="right" valign="top"><a id="a420bfe8f24dd900f595369ef59b892c1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmce_1_1timer__service.html#a420bfe8f24dd900f595369ef59b892c1">count</a> ()</td></tr>
<tr class="memdesc:a420bfe8f24dd900f595369ef59b892c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of running timers. <br /></td></tr>
<tr class="separator:a420bfe8f24dd900f595369ef59b892c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A tiny asynchronous timer service implementation. This service is not designed to work inside of coroutines and is unsafe to do so, it will almost certainly cause deadlock. To safely interact with coroutines, extra work must be done so that the timeout_handler executes threadsafe code (which can include rescheduling a coroutine or notifying a coroutine via a channel).</p>
<p>Start the service: <a class="el" href="structmce_1_1timer__service.html">mce::timer_service</a> my_timer_service; std::thread thd([&amp;]{ my_timer_service.start(); }).detach(); my_timer_service.ready(); // block until started</p>
<p>Usage is as simple as: mce::timer_id tid = my_timer_service.timer(mce::time_unit::microsecond, microsecs_till_timeout, my_timeout_handler, false);</p>
<p>The timer can be synchronously removed (if it is not already executing) with: my_timer_service.remove(tid); </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0df685790cca2967cd69fbba54d3dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0df685790cca2967cd69fbba54d3dd0">&#9670;&nbsp;</a></span>~timer_service()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mce::timer_service::~timer_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shutdown and join with asynchronous timer service if <a class="el" href="structmce_1_1timer__service.html#ae37f2d6584e8c8bb775a2961c0916909" title="inform service to shutdown and join with service">shutdown()</a> has not been previously called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2577939853b10b0bd24c0da11b44182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2577939853b10b0bd24c0da11b44182b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mce::timer_service::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove all pending timers </p>
<p>WARNING: This is a very, <em>very</em> dangerous operation. Any timeout handler which expects to be called and has no handling for being destroyed early may cause <em>problems</em> in code. </p>

</div>
</div>
<a id="ad49692dfba6f88fa6248b60222fc316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49692dfba6f88fa6248b60222fc316a">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mce::timer_service::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove a running timer </p>
<p>If an enqueued timer is found, it is removed. If the target timer is currently* executing, this function will block and not return until the timeout handler completes, ensuring the target timer does not exist by the time this function returns.</p>
<dl class="section return"><dt>Returns</dt><dd>true if timer was found and removed, else returns false. </dd></dl>

</div>
</div>
<a id="aad7194412c78c80a697b62f695c2abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7194412c78c80a697b62f695c2abd3">&#9670;&nbsp;</a></span>timer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THUNK &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a> mce::timer_service::timer </td>
          <td>(</td>
          <td class="paramtype">const mce::duration &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THUNK &amp;&amp;&#160;</td>
          <td class="paramname"><em>timeout_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start timer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the duration till the timeout_handler should be executed </td></tr>
    <tr><td class="paramname">timeout_handler</td><td>a Callable accepting no arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timer id object </dd></dl>

</div>
</div>
<a id="a9f41ed7d27dcea436dc7cb67325d6539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f41ed7d27dcea436dc7cb67325d6539">&#9670;&nbsp;</a></span>timer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THUNK &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a> mce::timer_service::timer </td>
          <td>(</td>
          <td class="paramtype">const mce::time_point &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THUNK &amp;&amp;&#160;</td>
          <td class="paramname"><em>timeout_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start timer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the time when the timeout_handler should be executed </td></tr>
    <tr><td class="paramname">timeout_handler</td><td>a Callable accepting no arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timer id object </dd></dl>

</div>
</div>
<a id="a4549f972efbe5078434c179038e2cf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4549f972efbe5078434c179038e2cf95">&#9670;&nbsp;</a></span>timer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THUNK &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmce_1_1timer__service_1_1timer__id.html">timer_id</a> mce::timer_service::timer </td>
          <td>(</td>
          <td class="paramtype">const time_unit&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THUNK &amp;&amp;&#160;</td>
          <td class="paramname"><em>timeout_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start timer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_unit</td><td>the unit of time measurement to be used </td></tr>
    <tr><td class="paramname">count</td><td>the time_unit count till the timeout_handler should be executed </td></tr>
    <tr><td class="paramname">timeout_handler</td><td>a Callable accepting no arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timer id object </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>inc/mce/<a class="el" href="timer_8hpp_source.html">timer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
