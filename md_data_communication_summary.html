<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppCoroutineCurrency: Summary of Data Communication Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CppCoroutineCurrency
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Summary of Data Communication Operations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md91"></a>
A word about concurrency</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>While all channel objects below can be used with <code>std::thread</code> their simplest and most efficient usage occurs when used when running in a <code><a class="el" href="structmce_1_1coroutine.html">mce::coroutine</a></code> provided by the concurrency features of this library.</p>
<p>See <a class="el" href="md_concurrency_summary.html">Concurrency Summary</a>.</p>
<h1><a class="anchor" id="autotoc_md92"></a>
Table of Contents</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<ul>
<li><a href="#shared-channel-api">shared channel API</a></li>
<li><a href="#sending-void">sending void</a></li>
<li><a href="#unbuffered-channel">unbuffered channel</a></li>
<li><a href="#buffered-channel">buffered channel</a></li>
<li><a href="#chan">chan</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md93"></a>
shared channel API</h2>
<p>The following is taken from <code><a class="el" href="base__channel_8hpp.html">mce/base_channel.hpp</a></code>. All objects therein are in the <code>mce</code> namespace.</p>
<p>The following result enum is provided: </p><div class="fragment"><div class="line">// enum for channel operation results</div>
<div class="line">enum result </div>
<div class="line">{</div>
<div class="line">    // ensure closed is convertable to `false`, allowing while(try_...()) operation loops</div>
<div class="line">    closed = 0, /// channel is closed, operation failed</div>
<div class="line">    success, /// blocking/nonblocking operation succeeded</div>
<div class="line">    failure /// nonblocking operation failed</div>
<div class="line">};</div>
</div><!-- fragment --><p>All channel objects implement or inherit the following API from <code><a class="el" href="structmce_1_1base__channel.html">mce::base_channel</a>&lt;T&gt;</code>: </p><div class="fragment"><div class="line">// Constructs the underlying channel context. Must be called or copied from </div>
<div class="line">// another channel before other operations are called. Copies of channels </div>
<div class="line">// communicate to one another through their shared context.</div>
<div class="line">virtual void construct() const = 0; </div>
<div class="line"> </div>
<div class="line">virtual const std::type_info&amp; type_info() const = 0; // retrieve type_info for the channel</div>
<div class="line">virtual void* context() const= 0; // return the internal context pointer</div>
<div class="line">virtual void close() const= 0; // close the channel</div>
<div class="line">virtual bool closed() const= 0; // return true if the channel is close, else false</div>
<div class="line">virtual bool send(const T&amp; s) const= 0; // send value over the channel</div>
<div class="line">virtual bool send(T&amp;&amp; s) const= 0; // move value over the channel</div>
<div class="line">virtual bool recv(T&amp; r) const; // receive value over the channel</div>
<div class="line">virtual result try_send(const T&amp; s) const= 0; // attempt to send a value over the channel</div>
<div class="line">virtual result try_send(T&amp;&amp; s) const= 0; // attempt to move a value over the channel</div>
<div class="line">virtual result try_recv(T&amp; r) const= 0; // attempt to receive a value over the channel</div>
<div class="line">base_channel&lt;T&gt;::iterator begin() const; // retrieve iterator to next value received on the channel</div>
<div class="line">base_channel&lt;T&gt;::iterator end() const; // retrieve an iterator to the end/closed state of the channel</div>
</div><!-- fragment --><p>For clarification, the reason all operations and returned references are const is because channels are designed to <em>ignore</em> const designations. This is because channels are designed as a trivially easy mechanism for communication and are intended to be copied by capture in lambdas. Unfortunately, unless the lambda in question is designated "mutable" the captures will become const by default, which would make channels useless.</p>
<p>While this design quirk is certainly an anti-pattern, it exists to combat the greater anti pattern of having to mark every user lambda as mutable (which also limits the usable forms of lambda notation). So for the sake simplicity and readability all derived channels which inherit base_channel will typically need to specify its members as mutable.</p>
<p>All channels also inherit the following operator overloads from <code><a class="el" href="structmce_1_1channel__operators.html">mce::channel_operators</a>&lt;T,CHANNEL&gt;</code>: </p><div class="fragment"><div class="line">/*</div>
<div class="line"> Statically construct a channel with CHANNEL::construct(as...) </div>
<div class="line"> </div>
<div class="line"> @params optional context constructor arguments</div>
<div class="line"> @return the constructed channel</div>
<div class="line"> */</div>
<div class="line">template &lt;typename... As&gt;</div>
<div class="line">static CHANNEL make(As&amp;&amp;... as);</div>
<div class="line"> </div>
<div class="line">virtual void assign(const CHANNEL&amp; rhs) const = 0; // copy context function</div>
<div class="line">virtual void assign(CHANNEL&amp;&amp; rhs) const = 0; // move context function</div>
<div class="line">explicit operator bool() const; // return whether context() is non-NULL</div>
<div class="line">bool operator=(const CHANNEL&lt;T&gt;&amp; rhs) const; // copy context from argument channel</div>
<div class="line">bool operator=(CHANNEL&lt;T&gt;&amp;&amp; rhs) const; // copy context from argument channel</div>
<div class="line">bool operator==(const CHANNEL&lt;T&gt;&amp; rhs) const; // return true if channels share context, else return false</div>
<div class="line">bool operator==(CHANNEL&amp;&amp; rhs) const; // return true if channels share context, else return false</div>
<div class="line">bool operator!=(const CHANNEL&lt;T&gt;&amp; rhs) const; // return false if channels share context, else return true</div>
<div class="line">bool operator!=(CHANNEL&lt;T&gt;&amp;&amp; rhs) const;  // return false if channels share context, else return true</div>
</div><!-- fragment --><p>Channels function equivalently for both <code>std::thread</code> operating system threads AND for <code><a class="el" href="structmce_1_1coroutine.html">mce::coroutine</a></code> coroutines (any function scheduled with <code><a class="el" href="threadpool_8hpp.html#a60e70d3b46c34e94edf9f8e00442bffb" title="Launch user function and optional arguments as a coroutine running on a scheduler.">mce::parallel()</a></code>, <code><a class="el" href="threadpool_8hpp.html#a3ef2c7400038d8f79596c4ae2055df79" title="Launch user function and optional arguments as a coroutine running on a scheduler.">mce::concurrent()</a></code>, <code>mce::threadpool::schedule()</code>, or <code><a class="el" href="structmce_1_1scheduler.html#a013cd1b794606776a4c409f50ac437f1" title="schedule allocated coroutine(s)">mce::scheduler::schedule()</a></code> is converted to and executed as a coroutine).</p>
<p>That is, any 'blocking' operation is handled correctly in both cases, allowing other threads and coroutines to run while the caller is blocked.</p>
<p>The <code>try_</code> variant of sends and receives will return a <code>mce::result::success</code> if the operation succeeded, <code>mce::result::failure</code> if the operation failed or <code>mce::result::closed</code> if the channel is closed. In some cases (like <code>unbuffered_channel</code>) if both the sender and receiver use only <code>try_</code> calls, no operation will EVER succeed, because internally the <code>try_</code> operations require a blocking complimentary receiver or sender. Best practice is to avoid using <code>try_</code> entirely for most operations. However, if <code>try_</code> methods must be used communication problems can be generally solved by having only one side of a send/receive use a <code>try_</code> variant, with the other side using a blocking call.</p>
<p>Calling <code>close()</code> on the channel causes all code blocked on said channel or any future calls to this channel's communication API (other than <code>make()</code>, <code>close()</code>, <code>closed()</code>, or other non-communication functionality) will cause said opereations to fail.</p>
<p>Channel iterators are equal to <code>base_channel&lt;T&gt;::iterator::end()</code> once the channel is closed. Operator <code>++</code> will internally call a blocking <code>recv()</code>. If the channel is closed during this operation, the iterator will become == to <code>end()</code>.</p>
<p>Channel iterators are <code>std::input_iterator</code>s (and inherit <code>std::input_iterator_tag</code>), meaning they support the following operators: </p><div class="fragment"><div class="line">const iterator&amp; operator=(const iterator&amp; rhs) const;</div>
<div class="line">const iterator&amp; operator=(iterator&amp;&amp; rhs) const;</div>
<div class="line">bool operator==(const iterator&amp; rhs) const;</div>
<div class="line">bool operator==(iterator&amp;&amp; rhs) const;</div>
<div class="line">bool operator!=(const iterator&amp; rhs) const;</div>
<div class="line">bool operator!=(iterator&amp;&amp; rhs) const;</div>
<div class="line">T&amp; operator*() const;</div>
<div class="line">T* operator-&gt;() const;</div>
<div class="line">const iterator&amp; operator++() const;</div>
<div class="line">const iterator operator++(int) const;</div>
</div><!-- fragment --><p>Because channel objects implement iterators, they can be used in range-for loops, which will safely exit the loop when the channel is closed: </p><div class="fragment"><div class="line">void foo(mce::chan&lt;int&gt; ch)</div>
<div class="line">{</div>
<div class="line">    for(auto&amp; e : ch)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; &quot;e: &quot; &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md94"></a>
sending void</h2>
<p>Channels cannot be trivially templated to <code>void</code> because of how their shared API is designed. IE, <code>send(const T&amp;)</code> (and other code which references <code>T</code>) is invalid in <code>c++</code> when applied to type <code>void</code>.</p>
<p>The user who wants channel synchronization but wants to minimize copy costs can use basic types like <code>int</code>, <code>size_t</code>, or <code>char</code> as the templated type. However, a clarity workaround can be made by utilizing empty structs:</p>
<p><a href="ex/src/example_028.cpp">example_028 source</a> </p><div class="fragment"><div class="line">// example_028</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">// only an object pointer will be constructed, but no data will ever be copied</div>
<div class="line">struct void_t { };</div>
<div class="line"> </div>
<div class="line">void receiver(mce::chan&lt;void_t&gt; ch) {</div>
<div class="line">    void_t r;</div>
<div class="line">    ch.recv(r);</div>
<div class="line">    std::cout &lt;&lt; &quot;receiver received&quot; &lt;&lt; std::endl;</div>
<div class="line">    ch.send({});</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto ch = mce::chan&lt;void_t&gt;::make();</div>
<div class="line">    mce::concurrent(receiver, ch);</div>
<div class="line"> </div>
<div class="line">    ch.send({});</div>
<div class="line">    void_t r;</div>
<div class="line">    ch.recv(r);</div>
<div class="line">    std::cout &lt;&lt; &quot;main received&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_028</div>
<div class="line">receiver received</div>
<div class="line">main received</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md95"></a>
unbuffered channel</h2>
<p>Implemented in <code><a class="el" href="unbuffered__channel_8hpp.html">mce/unbuffered_channel.hpp</a></code> </p><div class="fragment"><div class="line">namespace mce {</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">class unbuffered_channel : public base_channel&lt;T&gt;, </div>
<div class="line">                           public channel_operators&lt;T,unbuffered_channel&lt;T&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Templated, synchronized communication mechanism to send data between concurrent code. This object <em>always</em> blocks on either <code>send()</code> or <code>recv()</code> until there is a complementary <code>recv()</code> or <code>send()</code>. The channel does not allocate storage space for the data being sent, it directly copies or moves the data from the sender to the receiver.</p>
<p>unbuffered_channel is special in that its <code>try_send()</code>/<code>try_recv()</code> operations still require a complimentary blocking <code>recv()</code>/<code>send()</code> or they will <em>always fail</em>.</p>
<p><a href="ex/src/example_021.cpp">example_021 source</a> </p><div class="fragment"><div class="line">// example_021</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    mce::unbuffered_channel&lt;int&gt; ch1;</div>
<div class="line">    mce::unbuffered_channel&lt;int&gt; ch2;</div>
<div class="line">    ch1.construct();</div>
<div class="line">    ch2.construct();</div>
<div class="line">    </div>
<div class="line">    std::thread thd([](mce::unbuffered_channel&lt;int&gt; ch1, </div>
<div class="line">                   mce::unbuffered_channel&lt;int&gt; ch2)</div>
<div class="line">    {</div>
<div class="line">        int x;</div>
<div class="line">        ch1.recv(x);</div>
<div class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">        ch2.send(0);</div>
<div class="line">    }, ch1, ch2);</div>
<div class="line">    </div>
<div class="line">    ch1.send(14);</div>
<div class="line">    int r;</div>
<div class="line">    ch2.recv(r);</div>
<div class="line">    thd.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_021</div>
<div class="line">14</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md96"></a>
buffered channel</h2>
<p>Implemented in <code><a class="el" href="buffered__channel_8hpp.html">mce/buffered_channel.hpp</a></code> </p><div class="fragment"><div class="line">namespace mce {</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">class buffered_channel : public base_channel&lt;T&gt;,</div>
<div class="line">                         public channel_operators&lt;T,buffered_channel&lt;T&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    // specialized or unique API:</div>
<div class="line"> </div>
<div class="line">    void construct(size_t sz); // allocate buffer of size sz</div>
<div class="line">    void construct(); // default buffer of size 1</div>
<div class="line">    size_t size() const; // return number of values stored in channel</div>
<div class="line">    bool empty() const; // return if there are no values in the channel</div>
<div class="line">    bool full() const; // return if channel buffer is full</div>
<div class="line">    size_t capacity() const; // return maximum number of storable values</div>
<div class="line">    size_t reserve() const; // return count of unused values in the buffer </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Templated communication mechanism to send data between concurrent code, with data stored in a statically sized buffer during transit. Only blocks on receive if no values are available in the internal buffer, and only blocks on <code>send()</code> if no room is left in the internal buffer.</p>
<p><code>buffered_channel</code> also provides the following extra API to manage its internal buffer: </p><div class="fragment"><div class="line">size_t size() const; // returns the count of values stored in the buffer</div>
<div class="line">size_t reserve() const; // return count of unused values in the buffer</div>
<div class="line">size_t capacity() const; // return the maximum number of storable values</div>
<div class="line">bool empty() const; // returns true if the buffer is empty, else false</div>
<div class="line">bool full() const; // returns true if the buffer is full, else false</div>
</div><!-- fragment --><p><a href="ex/src/example_022.cpp">example_022 source</a> </p><div class="fragment"><div class="line">// example_022</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    mce::buffered_channel&lt;int&gt; ch1;</div>
<div class="line">    mce::buffered_channel&lt;int&gt; ch2;</div>
<div class="line">    ch1.construct(1); // can hold 1 value before forcing the sender to block</div>
<div class="line">    ch1.construct(); // defaults to buffer size 1</div>
<div class="line">    ch1.construct(0); // defaults to buffer size 1</div>
<div class="line">    ch2.construct(30); // can hold 30 simultaneous values before forcing sender to block</div>
<div class="line">    </div>
<div class="line">    std::thread thd([](mce::buffered_channel&lt;int&gt; ch1, </div>
<div class="line">                   mce::buffered_channel&lt;int&gt; ch2)</div>
<div class="line">    {</div>
<div class="line">        int x;</div>
<div class="line">        ch1.recv(x);</div>
<div class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">        ch2.send(0);</div>
<div class="line">    }, ch1, ch2);</div>
<div class="line">    </div>
<div class="line">    ch1.send(42);</div>
<div class="line">    int r;</div>
<div class="line">    ch2.recv(r);</div>
<div class="line">    thd.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_022</div>
<div class="line">42</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md97"></a>
chan</h2>
<p>Implemented in <code><a class="el" href="chan_8hpp.html">mce/chan.hpp</a></code>, specialized or unique API: </p><div class="fragment"><div class="line">namespace mce {</div>
<div class="line">    </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">class chan : public base_channel&lt;T&gt;,</div>
<div class="line">             public channel_operators&lt;T,chan&lt;T&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    // specialized or unique API: </div>
<div class="line"> </div>
<div class="line">    // mechanism for constructing a chan&lt;T&gt; object using any object which </div>
<div class="line">    // implements base_channel&lt;T&gt;</div>
<div class="line">    template &lt;typename CHANNEL&gt;</div>
<div class="line">    void construct(CHANNEL&amp;&amp; ch) const;</div>
<div class="line"> </div>
<div class="line">    void construct() const; // construct unbuffered channel context </div>
<div class="line"> </div>
<div class="line">    size_t context_type_info() const; // returns the wrapped channel&#39;s std::type_info</div>
<div class="line"> </div>
<div class="line">    // cast base_channel context to templated channel and return the result. </div>
<div class="line">    template &lt;typename CHANNEL&gt; CHANNEL cast() const;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Wrapper object representing an unbuffered channel by default. However, using <code>chan</code>'s <code>construct()</code> call the <code>chan</code> can be constructed using <em>any</em> object which inherits the <code>base_channel</code> API including <code>unbuffered_channel</code>, <code>buffered_channel</code>, or a user-made channel object.</p>
<p><a href="ex/src/example_011.cpp">example_011 source</a> </p><div class="fragment"><div class="line">// example_011</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    mce::chan&lt;int&gt; ch1;</div>
<div class="line">    mce::chan&lt;int&gt; ch2;</div>
<div class="line">    ch1.construct(mce::buffered_channel&lt;int&gt;::make(1)); // is buffered</div>
<div class="line">    ch2.construct(); // is unbuffered</div>
<div class="line">    </div>
<div class="line">    std::thread thd([](mce::chan&lt;int&gt; ch1, mce::chan&lt;int&gt; ch2)</div>
<div class="line">    {</div>
<div class="line">        int x;</div>
<div class="line">        ch1.recv(x);</div>
<div class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">        ch2.send(5);</div>
<div class="line">    }, ch1, ch2);</div>
<div class="line">    </div>
<div class="line">    ch1.send(14);</div>
<div class="line">    int r;</div>
<div class="line">    ch2.recv(r);</div>
<div class="line">    std::cout &lt;&lt; r &lt;&lt; std::endl;</div>
<div class="line">    thd.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_011</div>
<div class="line">14</div>
<div class="line">5</div>
<div class="line">$</div>
</div><!-- fragment --><p>The type information of the wrapped channel object can be returned using <code><a class="el" href="structmce_1_1chan.html">mce::chan</a>&lt;T&gt;::context_type_info()</code>. IE, you can check if your <code><a class="el" href="structmce_1_1chan.html">mce::chan</a>&lt;T&gt;</code> represents a <code><a class="el" href="structmce_1_1unbuffered__channel.html">mce::unbuffered_channel</a>&lt;T&gt;</code> by comparing the return value of <code><a class="el" href="structmce_1_1chan.html">mce::chan</a>&lt;T&gt;::context_type_info()</code> with the <code>type_info()</code> returned from either calling <code>unbuffered_channel&lt;T&gt;::type_info()</code> or directly with the <code>typeid</code> operator (<code>typeid(unbuffered_channel&lt;T&gt;)</code>).</p>
<p>After determining the exact type wrapped in the <code><a class="el" href="structmce_1_1chan.html">mce::chan</a>&lt;T&gt;</code> object, you can retrieve a copy of that channel with <code><a class="el" href="structmce_1_1chan.html">mce::chan</a>&lt;T&gt;::cast&lt;CHANNEL&gt;()</code>:</p>
<div class="fragment"><div class="line">#include &lt;typeinfo&gt;</div>
<div class="line">#include &lt;mce/unbuffered_channel.hpp&gt;</div>
<div class="line">#include &lt;mce/chan.hpp&gt;</div>
<div class="line"> </div>
<div class="line">mce::unbuffered_channel&lt;int&gt; getUnbufferedChannel(mce::chan&lt;int&gt; ch)</div>
<div class="line">{</div>
<div class="line">    mce::unbuffered_channel&lt;int&gt; unb_ch;</div>
<div class="line"> </div>
<div class="line">    if(ch) // check if mce::chan&lt;int&gt; is initialized</div>
<div class="line">    {</div>
<div class="line">        if(ch.context_type_info() == unb_ch.type_info())</div>
<div class="line">        {</div>
<div class="line">            // extract a copy of the unbuffered_channel from chan wrapper</div>
<div class="line">            unb_ch = ch.cast&lt;mce::unbuffered_channel&lt;int&gt;&gt;();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return unb_ch;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
