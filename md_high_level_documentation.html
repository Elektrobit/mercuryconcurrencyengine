<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppCoroutineCurrency: High Level Cpp Coroutine Concurrency Summary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CppCoroutineCurrency
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">High Level Cpp Coroutine Concurrency Summary </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md36"></a>
Table of Contents</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<ul>
<li><a href="#running-code-as-a-concurrent-coroutine">Running code as a concurrent coroutine</a></li>
<li><a href="#channels-explained">Channels explained</a></li>
<li><a href="#simplifying-channels-with-chan">Simplifying channels with chan</a></li>
<li><a href="#channel-iterators">Channel iterators</a></li>
<li><a href="#using-coroutines-and-channels-to-generate-asynchronous-futures">Using coroutines and channels to generate asynchronous futures</a></li>
<li><a href="#running-coroutines-blocking-on-other-coroutines">Running coroutines blocking on other coroutines</a></li>
<li><a href="#running-coroutines-with-blocking-calls">Running coroutines with blocking calls</a></li>
<li><a href="#behind-the-scenes">Behind the scenes</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md37"></a>
Running code as a concurrent coroutine</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>The functions <code><a class="el" href="threadpool_8hpp.html#a3ef2c7400038d8f79596c4ae2055df79" title="Launch user function and optional arguments as a coroutine running on a scheduler.">mce::concurrent()</a></code>, <code><a class="el" href="threadpool_8hpp.html#a60e70d3b46c34e94edf9f8e00442bffb" title="Launch user function and optional arguments as a coroutine running on a scheduler.">mce::parallel()</a></code> and <code><a class="el" href="threadpool_8hpp.html#a775daca1186f81e5410f2298abf5b832" title="Launch user function and optional arguments as a coroutine running on a scheduler....">mce::balance()</a></code> will launch a given function or Callable (and any arguments) as a concurrently executing coroutine. Data can be communicated between coroutines and threads via channels (<code><a class="el" href="structmce_1_1chan.html">mce::chan</a></code>, <code><a class="el" href="structmce_1_1unbuffered__channel.html">mce::unbuffered_channel</a></code>, <code><a class="el" href="structmce_1_1buffered__channel.html">mce::buffered_channel</a></code>) and their <code>send()</code> and <code>recv()</code> methods.</p>
<p>A trivial example:</p>
<p><a href="ex/src/example_005.cpp">example_005 source</a> </p><div class="fragment"><div class="line">// example_005</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">void my_function(int arg0, std::string arg1, mce::chan&lt;int&gt; done_ch)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; &quot;arg0: &quot;</div>
<div class="line">              &lt;&lt; arg0</div>
<div class="line">              &lt;&lt; &quot;; arg1: &quot;</div>
<div class="line">              &lt;&lt; arg1 </div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    done_ch.send(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    mce::chan&lt;int&gt; done_ch = mce::chan&lt;int&gt;::make();</div>
<div class="line"> </div>
<div class="line">    // execute functions as a parallel, concurrent coroutine using the parallel() call</div>
<div class="line">    mce::parallel(my_function, 3, &quot;hello world&quot;, done_ch);</div>
<div class="line"> </div>
<div class="line">    // wait for a coroutine to send a value over done_ch before returning</div>
<div class="line">    int r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_005</div>
<div class="line">arg0: 3; arg1: hello world</div>
</div><!-- fragment --><p>See <a class="el" href="md_concurrency_summary.html">concurrency summary</a> for more information</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Channels explained</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p><code><a class="el" href="structmce_1_1unbuffered__channel.html">mce::unbuffered_channel</a></code>s, <code><a class="el" href="structmce_1_1buffered__channel.html">mce::buffered_channel</a></code>s and are synchronized communication mechanisms for sending values between places in code (running on any combination of normal threads or coroutines). A third type of channel called <code>mce::broadcast_channel</code> exists but functions slightly differently from the other two.</p>
<p>All channels must have their <code>construct()</code> function called OR assigned their internals from another channel before they can function (a new channel with constructed context can be generated with a call to a channel's static <code>make()</code> procedure). This is because channels are merely <em>interfaces</em> to shared data internals.</p>
<p><code><a class="el" href="structmce_1_1unbuffered__channel.html">mce::unbuffered_channel</a></code>s communicate data and force both the sender and recipient to block until both are ready. This means that the sender or receiver will always block if there is no complementary blocking receiver or sender.</p>
<p><code><a class="el" href="structmce_1_1buffered__channel.html">mce::buffered_channel</a></code>s communicate data asynchronously. Send operations only block when no room remains in the internal data container. Receive operations only block when no values remain unclaimed in the internal data container.</p>
<p>Both variants use <code>send()</code> operations to send data into the channel and <code>recv()</code> operations to retrieve data from the channel.</p>
<p><em>Warning: It is best to make copies of channels, so the shared internals do not unexpectedly go out of scope.</em></p>
<p><a href="ex/src/example_006.cpp">example_006 source</a> </p><div class="fragment"><div class="line">// example_006</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">void func(mce::buffered_channel&lt;std::string&gt; out_ch)</div>
<div class="line">{</div>
<div class="line">    out_ch.send(&quot;hello&quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void func2(mce::buffered_channel&lt;std::string&gt; in_ch, mce::unbuffered_channel&lt;int&gt; done_ch)</div>
<div class="line">{</div>
<div class="line">    std::string s;</div>
<div class="line">    in_ch.send(s);</div>
<div class="line">    std::cout &lt;&lt; &quot;func said &quot; &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    done_ch.send(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    // has an internal container that can hold 3 simultaneous values</div>
<div class="line">    auto ch = mce::buffered_channel&lt;std::string&gt;::make(3);</div>
<div class="line">    </div>
<div class="line">    // has no internal container for values</div>
<div class="line">    auto done_ch = mce::unbuffered_channel&lt;int&gt;::make(); </div>
<div class="line"> </div>
<div class="line">    mce::parallel(func, ch);</div>
<div class="line">    mce::parallel(func2, ch, done_ch);</div>
<div class="line"> </div>
<div class="line">    int r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_006</div>
<div class="line">func said hello</div>
</div><!-- fragment --><p>As a note, all channels support the function <code>void close()</code>, which will cause all current and future communication operations (such as <code>send()</code> and <code>recv()</code>) to fail. It will also unblock coroutines and threads using the channel.</p>
<p><code><a class="el" href="structmce_1_1unbuffered__channel.html">mce::unbuffered_channel</a></code>s and mce::<code>buffered_channel</code>s also have other functions such as <code>try_recv()</code> in addition to their standard methods. See <a class="el" href="md_data_communication_summary.html">data communication summary</a> for more information.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Simplifying channels with chan</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>The <code><a class="el" href="structmce_1_1chan.html">mce::chan</a></code> object is a special wrapper object which can represent any channel which implements <code>mce:base_channel</code>, such as an <code><a class="el" href="structmce_1_1unbuffered__channel.html">mce::unbuffered_channel</a></code>, <code><a class="el" href="structmce_1_1buffered__channel.html">mce::buffered_channel</a></code>, and <code>mce::broadcast_channel</code>. Because of this, it only directly gives access to API provided by (or implementable with said API) <code><a class="el" href="structmce_1_1base__channel.html">mce::base_channel</a></code>.</p>
<p>If you don't want subsequent functions to bother about what kind of channel they are using or simply want more readable code use <code><a class="el" href="structmce_1_1chan.html">mce::chan</a></code>.</p>
<p><a href="ex/src/example_007.cpp">example_007 source</a> </p><div class="fragment"><div class="line">// example_007</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    // is a buffered channel</div>
<div class="line">    mce::chan&lt;std::string&gt; buf_ch = mce::chan&lt;std::string&gt;::make(mce::buffered_channel&lt;std::string&gt;::make(3));</div>
<div class="line">    </div>
<div class="line">    // no channel provided, defaults to unbuffered_channel</div>
<div class="line">    mce::chan&lt;std::string&gt; unbuf_ch = mce::chan&lt;std::string&gt;::make(); </div>
<div class="line">    </div>
<div class="line">    mce::chan&lt;int&gt; done_ch = mce::chan&lt;int&gt;::make();</div>
<div class="line">    </div>
<div class="line">    auto my_function = [](mce::chan&lt;std::string&gt; ch1, </div>
<div class="line">                          mce::chan&lt;std::string&gt; ch2, </div>
<div class="line">              mce::chan&lt;int&gt; done_ch)</div>
<div class="line">    {</div>
<div class="line">        std::string r1;</div>
<div class="line">        std::string r2;</div>
<div class="line">        ch1.recv(r1);</div>
<div class="line">        ch2.recv(r2);</div>
<div class="line">        std::cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; r1 &lt;&lt; &quot;; ch2: &quot; &lt;&lt; r2 &lt;&lt; std::endl;</div>
<div class="line">        done_ch.send(0);</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    mce::parallel(my_function, buf_ch, unbuf_ch, done_ch);</div>
<div class="line">    </div>
<div class="line">    buf_ch.send(&quot;hello&quot;);</div>
<div class="line">    unbuf_ch.send(&quot;world&quot;);</div>
<div class="line">    int r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_007</div>
<div class="line">ch1: hello; ch2: world</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md40"></a>
Channel iterators</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>All channels provide iterator support with <code>begin()</code> and <code>end()</code>, allowing usage in range-for loops. This behavior is very useful because channel iterators are == <code>end()</code> when the channel is closed, meaning you don't have to watch for operations to begin failing.</p>
<p>Iterators generated from parent type <code>base_channel&lt;TYPE&gt;</code> are <code>base_channel&lt;TYPE&gt;::iterator</code>. This pattern follows for the other channel types as well (IE <code>unbuffered_channel&lt;TYPE&gt;</code> has <code>unbuffered_channel&lt;TYPE&gt;::iterator</code>).</p>
<p><a href="ex/src/example_008.cpp">example_008 source</a> </p><div class="fragment"><div class="line">// example_008</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace mce;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    mce::chan&lt;std::string&gt; ch = mce::chan&lt;std::string&gt;::make();</div>
<div class="line">    mce::chan&lt;bool&gt; done_ch = mce::chan&lt;bool&gt;::make();</div>
<div class="line">    </div>
<div class="line">    auto sender = [=]</div>
<div class="line">    {</div>
<div class="line">        for(size_t cnt = 0; cnt&lt;10; ++cnt)</div>
<div class="line">        {</div>
<div class="line">            ch.send(std::string(&quot;hello&quot;) + std::to_string(cnt));</div>
<div class="line">        }</div>
<div class="line">        ch.close();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    auto receiver = [=]</div>
<div class="line">    {</div>
<div class="line">        for(auto&amp; s : ch)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        done_ch.send(true);</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    mce::parallel(sender);</div>
<div class="line">    mce::parallel(receiver);</div>
<div class="line">    bool r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Should print: </p><div class="fragment"><div class="line">$ ./ex</div>
<div class="line">hello0</div>
<div class="line">hello1</div>
<div class="line">hello2</div>
<div class="line">hello3</div>
<div class="line">hello4</div>
<div class="line">hello5</div>
<div class="line">hello6</div>
<div class="line">hello7</div>
<div class="line">hello8</div>
<div class="line">hello9</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
Using coroutines and channels to generate asynchronous futures</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>Combining the <code>mce::concurrent</code> function with channels allows trivial implementation of futures (where the channel is analogous to a <code>std::future</code> object provided when <code>std::async()</code> is called):</p>
<p><a href="ex/src/example_010.cpp">example_010 source</a> </p><div class="fragment"><div class="line">// example_010</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">const int the_number = 3;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    // this channel behaves like an std::future</div>
<div class="line">    mce::chan&lt;int&gt; ret_ch = mce::chan&lt;int&gt;::make(); </div>
<div class="line">    </div>
<div class="line">    mce::parallel([ret_ch]{ ret_ch.send(the_number); });</div>
<div class="line">   </div>
<div class="line">    int r;</div>
<div class="line">    ret_ch.recv(r);</div>
<div class="line">    std::cout &lt;&lt; &quot;The number: &quot; &lt;&lt; r &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_010</div>
<div class="line">The number: 3</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md42"></a>
Running coroutines blocking on other coroutines</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>Coroutines that detect they are blocked will suspend execution by communicating their blocked state and yielding to their calling context. Normally the calling context within this framework is a <code><a class="el" href="structmce_1_1scheduler.html" title="object responsible for scheduling and executing coroutines">mce::scheduler</a></code> object which is responsible for efficiently executing the next coroutine.</p>
<p>Unit testing shows that coroutine yield context switching is significantly faster than OS driven condition synchronization. Assuming that useful work is being done in at least one scheduler the overhead cost for this operation is minimal.</p>
<p>This example can be run alongside a process observation task (like taskmanager on windows or top on linux) to see that the process is not using cpu: </p><div class="fragment"><div class="line">// human_only_example_001</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    mce::chan&lt;int&gt; test_ch = mce::chan&lt;int&gt;::make();</div>
<div class="line"> </div>
<div class="line">    std::string inp;</div>
<div class="line"> </div>
<div class="line">    // CPU usage should be 0 because we are using OS level blocking when no </div>
<div class="line">    // tasks are available</div>
<div class="line">    std::cout &lt;&lt; &quot;wait for user input: &quot;;</div>
<div class="line">    std::cin &gt;&gt; inp;</div>
<div class="line"> </div>
<div class="line">    // spawn task that will block forever</div>
<div class="line">    mce::parallel([&amp;]{ int x; test_ch.recv(x);});</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;wait for user input2: &quot;;</div>
<div class="line">    std::cin &gt;&gt; inp;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md43"></a>
Running coroutines with blocking calls</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<p>A consequence of true blocking behavior is that by definition it blocks the entire thread. In the case of a thread running multiple coroutines this will therefore block all other coroutines from running, causing extreme delay (or deadlock if any coroutines require interaction from another coroutine on the blocked thread).</p>
<p>This is a common pain point for tasks that need to do blocking operations, that is, to interact with the operating system or other processes in a way that causes the caller to block for an indefinite amount of time.</p>
<p>Instead, <code><a class="el" href="await_8hpp.html#a11e991f059963fa96c32a1dc33975e5f" title="Execute Callable potentially on a different thread and block current context until operation complete...">await()</a></code> blocks a coroutine (in a way that allows other coroutines to execute in the meantime) and to execute the function passed to <code><a class="el" href="await_8hpp.html#a11e991f059963fa96c32a1dc33975e5f" title="Execute Callable potentially on a different thread and block current context until operation complete...">await()</a></code> on another (non-threadpool) thread running a scheduler without blocking other coroutines.</p>
<p>Here is a working example:</p>
<p><a href="ex/src/example_012.cpp">example_012 source</a> </p><div class="fragment"><div class="line">// example_012</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">void my_function(mce::buffered_channel&lt;int&gt; done_ch)</div>
<div class="line">{</div>
<div class="line">    mce::thunk t = []</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; &quot;executing on thread &quot; </div>
<div class="line">                  &lt;&lt; std::this_thread::get_id() </div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    t();</div>
<div class="line"> </div>
<div class="line">    // launch a new thread, block the current coroutine or thread, execute t </div>
<div class="line">    // on the new thread, then unblock the calling thread with the result</div>
<div class="line">    mce::await(t);</div>
<div class="line"> </div>
<div class="line">    t();</div>
<div class="line"> </div>
<div class="line">    done_ch.send(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    mce::buffered_channel&lt;int&gt; done_ch;</div>
<div class="line">    done_ch.construct();</div>
<div class="line"> </div>
<div class="line">    // execute functions as coroutines with the concurrent() call</div>
<div class="line">    mce::parallel(my_function, done_ch);</div>
<div class="line"> </div>
<div class="line">    // wait for a coroutine to send a value over done_ch before returning</div>
<div class="line">    int x; </div>
<div class="line">    done_ch.recv(x);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_012</div>
<div class="line">executing on thread 139945936029440</div>
<div class="line">executing on thread 139945902323456</div>
<div class="line">executing on thread 139945936029440</div>
</div><!-- fragment --><p>Any function or lambda passed to <code><a class="el" href="await_8hpp.html#a11e991f059963fa96c32a1dc33975e5f" title="Execute Callable potentially on a different thread and block current context until operation complete...">await()</a></code> can reference local variables safely. This is because local variables exist in a context which is guaranteed to be blocked while the function passed to <code><a class="el" href="await_8hpp.html#a11e991f059963fa96c32a1dc33975e5f" title="Execute Callable potentially on a different thread and block current context until operation complete...">await()</a></code> is running.</p>
<p><a href="ex/src/example_001.cpp">example_001 source</a> </p><div class="fragment"><div class="line">#include &lt;fstream&gt;</div>
<div class="line">#include &lt;sstream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;mce/mce.hpp&gt;</div>
<div class="line"> </div>
<div class="line">void read_file_content(std::string fname, mce::chan&lt;int&gt; done_ch) {</div>
<div class="line">    std::string fileContent;</div>
<div class="line"> </div>
<div class="line">    // create a function to execute in mce::await() that accesses the caller&#39;s stack </div>
<div class="line">    auto read_file = [&amp;] {</div>
<div class="line">        std::ifstream file(fname); // open file</div>
<div class="line"> </div>
<div class="line">        if(file.is_open()) { </div>
<div class="line">            std::ostringstream ss;</div>
<div class="line">            ss &lt;&lt; file.rdbuf(); // extract file contents</div>
<div class="line">            fileContent = ss.str();</div>
<div class="line">            return true; // await() will return what the input function returns</div>
<div class="line">        } else { </div>
<div class="line">            return false; </div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    // wait for boolean return value of read_file function</div>
<div class="line">    if(mce::await(read_file)) { </div>
<div class="line">        std::cout &lt;&lt; &quot;file successfully read&quot; &lt;&lt; std::endl; </div>
<div class="line">    } else { </div>
<div class="line">        std::cout &lt;&lt; &quot;failed to read file&quot; &lt;&lt; std::endl; </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;fileContent: &quot; &lt;&lt; fileContent &lt;&lt; std::endl;</div>
<div class="line">    done_ch.send(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv) {</div>
<div class="line">    // this is test setup, just ensuring there is a file to read</div>
<div class="line">    std::string fname(&quot;my_filename.txt&quot;);</div>
<div class="line">    std::ofstream file(fname, std::ios_base::trunc);</div>
<div class="line"> </div>
<div class="line">    if(file) {</div>
<div class="line">        file &lt;&lt; &quot;hello world!&quot;;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    file.close();</div>
<div class="line"> </div>
<div class="line">    // launch asynchronous coroutine to read the file content </div>
<div class="line">    auto done_ch = mce::chan&lt;int&gt;::make(); </div>
<div class="line">    mce::parallel(read_file_content, fname, done_ch);</div>
<div class="line"> </div>
<div class="line">    // wait for coroutine to finish before the program exits</div>
<div class="line">    int r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_001</div>
<div class="line">file successfully read</div>
<div class="line">fileContent: hello world!</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md44"></a>
Using timers</h1>
<p>The <code>mce</code> library provides is an object called <code><a class="el" href="structmce_1_1timer__service.html">mce::timer_service</a></code> in <code><a class="el" href="timer_8hpp.html">timer.hpp</a></code> (see "timer service" in <a class="el" href="md_concurrency_summary.html">Summary of Concurrent Operations</a> for more information on this object), which can scheduler timers. This object requires its own system thread to run on. Unless disabled by compiler define MCE_DISABLE_DEFAULT_TIMER_THREADS, this frameworks provides a default <code><a class="el" href="structmce_1_1timer__service.html">mce::timer_service</a></code> running on a background worker thread accessible via function <code>std::shared_pointer&lt;<a class="el" href="structmce_1_1timer__service.html">mce::timer_service</a>&gt; <a class="el" href="timer_8hpp.html#ae0c5845b438107a32cdde80510a3f5f7" title="Access to default mce::timer_service object.">mce::default_timer_service()</a></code>.</p>
<p>It should be noted that the toplevel <code><a class="el" href="timer_8hpp.html#a4f3d651eea461040f92652f0f2455ea0" title="launch a timer with a Callable to be called on timeout">mce::timer()</a></code> operation launch timers whose timeouts occur <em>as a coroutine</em> on the same <code><a class="el" href="structmce_1_1scheduler.html" title="object responsible for scheduling and executing coroutines">mce::scheduler</a></code> of the system thread the <code><a class="el" href="timer_8hpp.html#a4f3d651eea461040f92652f0f2455ea0" title="launch a timer with a Callable to be called on timeout">mce::timer()</a></code> was called on. This is behavior causes timeouts to be "asynchronous" but they execute on the same thread that launched them, instead of on a dedicated timer_service thread.</p>
<p>To alert coroutines on timeout with a <code><a class="el" href="structmce_1_1timer__service.html">mce::timer_service</a></code> the user can use channels: </p><div class="fragment"><div class="line">#include &lt;mce/scheduler.hpp&gt;</div>
<div class="line">#include &lt;mce/io.hpp&gt;</div>
<div class="line">#include &lt;mce/timer.hpp&gt;</div>
<div class="line"> </div>
<div class="line">my_value my_coroutine() {</div>
<div class="line">    auto ch = mce::chan&lt;int&gt;::make();</div>
<div class="line">    mce::default_timer_service()-&gt;timer(mce::time_unit::millisecond, 500, [=]{ ch.send(0);});</div>
<div class="line">    int done;</div>
<div class="line">    ch.recv(done); // block until timeout</div>
<div class="line"> </div>
<div class="line">    //... continue operations</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above business logic is similar to how <code><a class="el" href="timer_8hpp.html#abccb4fe0939b4eb26cd7e8a70c3b33d2" title="Put coroutine or thread to sleep in a blocking fashion.">mce::sleep()</a></code> calls operate.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Behind the scenes</h1>
<p><img src="img/mercury_icon_tiny.png" alt="mercury_icon" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md46"></a>
A note on reference bindings</h2>
<p>Throughout this library various functions will take other functions and an optional set of arguments which are internally bound together using <code>std::bind()</code>. Example functions which have this behavior: </p><div class="fragment"><div class="line">template &lt;typename F, typename... A&gt; void mce::concurrent(F&amp;&amp;, A&amp;&amp;...);</div>
<div class="line">template &lt;typename F, typename... A&gt; void mce::await(F&amp;&amp;, A&amp;&amp;...);</div>
<div class="line">template &lt;typename F, typename... As&gt; mce::timer_id mce::timer(mce::time_unit u, std::uint64_t count, F&amp;&amp; f, As&amp;&amp;...);</div>
<div class="line">template &lt;typename F, typename... As&gt; mce::timer_id mce::timer(mce::duration d, F&amp;&amp; f, As&amp;&amp;...);</div>
<div class="line">template &lt;typename F, typename... As&gt; mce::timer_id mce::timer(mce::time_point timeout, F&amp;&amp; f, As&amp;&amp;...);</div>
</div><!-- fragment --><p>When this happens the <em>ONLY</em> way to pass an argument by reference is to use <code>std::ref</code> or <code>std::cref</code>. This limitation is imposed by c++ <code>std::bind</code>.</p>
<p><a href="ex/src/example_003.cpp">example_003 source</a> </p><div class="fragment"><div class="line">// example_003</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">void modify_reference(int&amp; i, int val, mce::chan&lt;bool&gt; done_ch)</div>
<div class="line">{ </div>
<div class="line">    i = val; </div>
<div class="line">    done_ch.send(true);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    int i=0;</div>
<div class="line">    auto done_ch = mce::chan&lt;bool&gt;::make();</div>
<div class="line">    mce::parallel(modify_reference, std::ref(i), 2, done_ch);</div>
<div class="line">    // ensure modify_reference is complete before reading i</div>
<div class="line">    bool r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_003</div>
<div class="line">i: 2</div>
</div><!-- fragment --><p>An easier solution is to use lambda reference captures:</p>
<p><a href="ex/src/example_004.cpp">example_004 source</a> </p><div class="fragment"><div class="line">// example_004</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;mce.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    int i=0;</div>
<div class="line">    auto done_ch = mce::chan&lt;bool&gt;::make();</div>
<div class="line">    auto modify_reference = [=,&amp;i](int val){ i = val; done_ch.send(true); };</div>
<div class="line">    mce::parallel(modify_reference, 2);</div>
<div class="line">    bool r;</div>
<div class="line">    done_ch.recv(r);</div>
<div class="line">    std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_004</div>
<div class="line">i: 2</div>
</div><!-- fragment --><p>However, it should be noted that modifying by reference on different threads without synchronization is often an error and can cause the program to crash. This can be avoided by coroutines running on the <em>same</em> thread, but it is generally better to avoid the situation entirely and communicate instead through channels.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Thunks!</h2>
<p>This project makes extensive use of thunks, also known as nullary lambdas. Lambdas are anonymous functions, which is a complicated way of saying they are functions we can define and manage <em>inside other functions</em>. A thunk is a function which takes no arguments and returns no value. While this sounds useless, lambdas can "capture context", allowing them to take references or make copies of data available in the current scope while they are being constructed:</p>
<p><a href="ex/src/example_013.cpp">example_013 source</a> </p><div class="fragment"><div class="line">// example_013</div>
<div class="line">#include &lt;functional&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** arv)</div>
<div class="line">{</div>
<div class="line">    int c=0;</div>
<div class="line">    std::function&lt;void()&gt; my_thunk = [&amp;]{ ++c; };</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; std::endl; // prints 0</div>
<div class="line">    my_thunk();</div>
<div class="line">    std::cout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; std::endl; // prints 1</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output: </p><div class="fragment"><div class="line">$ ./ex/example_013</div>
<div class="line">c: 0</div>
<div class="line">c: 1</div>
</div><!-- fragment --><p>Using the ability to capture context we can do some incredible things. As a usability improvement mce provides some helper types and functions in "thunk.hpp" should the user desire to implement features similar to this library.</p>
<div class="fragment"><div class="line">#include &lt;mce/thunk.hpp&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">void some_func()</div>
<div class="line">{</div>
<div class="line">    mce::thunk my_thunk = [&amp;]{ ... };</div>
<div class="line"> </div>
<div class="line">    // bind an arbitrary function to some arguments</div>
<div class="line">    mce::thunk my_thunk2 = mce::make_thunk(some_function, arg0, arg1, ..., argn);</div>
<div class="line"> </div>
<div class="line">    my_thunk();</div>
<div class="line">    my_thunk2();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
Segmented Coroutine Stacks</h2>
<p>At the moment, coroutines are created with whatever default stack allocator the boost coroutine2 library provides (which itself is determined by what is available from boost context). A more optimal solution would probably be using "segmented_stack" allocators. However, segmented_stack objects require that boost context be compiled with specific flags, which are not guaranteed to be set.</p>
<p>A potential enhancement might be the ability to initialize threadpools to a specific allocator type, allowing the default_threadpool to be enhanced as available. Of note, I believe the default allocator <em>is</em> a segmented stack allocator when it is available, so the current implementation would use that by default when compiled with the boost context library with segmented stacks enabled.</p>
<p>As it stands, the default behavior for coroutines launched via <a class="el" href="threadpool_8hpp.html#a3ef2c7400038d8f79596c4ae2055df79" title="Launch user function and optional arguments as a coroutine running on a scheduler.">concurrent()</a> potentially take more memory than necessary. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
